{
  "name": "Android.viewpagenavigation",
  "tagline": "",
  "body": "本文参照Android官方教程，笔者在学习时遇到一些问题，而且官方教程有些地方说的不太明白，所以进行了整理。\r\n\r\nAndroid的内置搜索功能，能够在app中方便地为所有用户提供一个统一的搜索体验。\r\n从Android 3.0开始，在action bar中使用SearchView作为item，是在你的app中提供搜索的一种更好方法。像其他所有在action bar中的item一样，你可以定义SearchView在有足够空间的时候总是显示，或设置为一个折叠操作(collapsible action),一开始SearchView作为一个图标显示，当用户点击图标时再显示搜索框占据整个action bar。\r\n### 添加Search View到action bar中\r\n为了在action bar中添加SearchView，在你的工程目录res/menu/中创建一个名为options_menu.xml的文件，再把下列代码添加到文件中。这段代码定义了如何创建search item，比如使用的图标和item的标题。collapseActionView属性允许你的SearchView占据整个action bar，在不使用的时候折叠成普通的action bar item。由于在手持设备中action bar的空间有限，建议使用collapsibleActionView属性来提供更好的用户体验。\r\n```\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:searchDemo=\"http://schemas.android.com/apk/res-auto\">\r\n    <item android:id=\"@+id/search\"\r\n        android:title=\"@string/search_title\"\r\n        android:icon=\"@drawable/ic_search\"\r\n        searchDemo:showAsAction=\"collapseActionView|ifRoom\"\r\n        searchDemo:actionViewClass=\"android.widget.SearchView\" />\r\n</menu>\r\n```\r\nNote:如果你的menu items已经有一个XML文件，你可以只把<item>元素添加入文件。\r\n要在action bar中显示SearchView，在你的activity中onCreateOptionsMenu())方法内填充XML菜单资源(res/menu/options_menu.xml):\r\n```\r\n@Override\r\npublic boolean onCreateOptionsMenu(Menu menu) {\r\n    MenuInflater inflater = getMenuInflater();\r\n    inflater.inflate(R.menu.options_menu, menu);\r\n\r\n    return true;\r\n}\r\n```\r\n如果你立即运行你的app，SearchView就会显示在你app的action bar中，但还无法使用。你现在需要定义SearchView如何运行。\r\n### 创建一个检索配置\r\n检索配置(searchable configuration)在 res/xml/searchable.xml文件中定义了SearchView如何运行。检索配置中至少要包含一个android:label属性，与Android manifest中的<application>或<activity>android:label属性值相同。但我们还是建议添加android:hint属性来告诉用户应该在搜索框中输入什么内容:\r\n```\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<searchable xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    android:hint=\"@string/search_hint\"\r\n    android:label=\"@string/app_name\" />\r\n```\r\nNote:这里的hint和label不要使用字节字符串。\r\n在MainActivity中输入搜索条件，我们还需要一个Activity来显示搜索结果，创建一个名为SearchResultsActivity的Activity，然后在manifest中进行相关配置。\r\n在MainActivity中配置要打开哪个Activity：\r\n```\r\n<activity android:name=\".MainActivity\">\r\n    <intent-filter>\r\n        <action android:name=\"android.intent.action.MAIN\" />\r\n\r\n        <category android:name=\"android.intent.category.LAUNCHER\" />\r\n    </intent-filter>\r\n    <meta-data\r\n        android:name=\"android.app.default_searchable\"\r\n        android:value=\".SearchResultsActivity\" />\r\n</activity>\r\n```\r\n在SearchResultsActivity中加入如下代码：\r\n```\r\n<meta-data\r\n    android:name=\"android.app.searchable\"\r\n    android:resource=\"@xml/searchable\" />\r\n```\r\n在你之前创建的onCreateOptionsMenu())方法中，调用setSearchableInfo(SearchableInfo))把SearchView和检索配置关联在一起:\r\n```\r\n@Override\r\npublic boolean onCreateOptionsMenu(Menu menu) {\r\n    MenuInflater inflater = getMenuInflater();\r\n    inflater.inflate(R.menu.options_menu, menu);\r\n\r\n    // 关联检索配置和SearchView\r\n    SearchManager searchManager =\r\n            (SearchManager) getSystemService(Context.SEARCH_SERVICE);\r\n    SearchView searchView =\r\n            (SearchView) menu.findItem(R.id.search).getActionView();\r\n    searchView.setSearchableInfo(\r\n            searchManager.getSearchableInfo(getComponentName()));\r\n\r\n    return true;\r\n}\r\n```\r\n检索配置与SearchView正确关联后，当用户提交一个搜索请求时，SearchView会以ACTION_SEARCH intent启动一个activity，这里会启动SearchResultsActivity。\r\n在你的检索activity中，通过在onCreate())方法中检查ACTION_SEARCH intent来处理它。\r\n```\r\nprotected void onCreate(Bundle savedInstanceState) {\r\n    super.onCreate(savedInstanceState);\r\n    setContentView(R.layout.search_result);\r\n    handleIntent(getIntent());\r\n}\r\n\r\n@Override\r\nprotected void onNewIntent(Intent intent) {\r\n    handleIntent(intent);\r\n}\r\n\r\nprivate void handleIntent(Intent intent) {\r\n\r\n    if (Intent.ACTION_SEARCH.equals(intent.getAction())) {\r\n        String query = intent.getStringExtra(SearchManager.QUERY);\r\n        //通过某种方法，根据请求检索你的数据\r\n        Log.i(AppConstants.DEBUG_TAG,\"-------输入的搜索关键字为：\"+query);\r\n    }\r\n}\r\n```\r\n如果你现在运行你的app，输入搜索关键字，确定后就会启动SearchResultsActivity，SearchResultsActivity能获取到你的查询条件。\r\n### 下面向你展示如何创建一个健壮的可以提供全文搜索的SQLite虚拟表。并从一个每行有一组单词-解释对的文件中将数据填入，作为数据源。\r\n向新疆一个实体类：Vocabulary，有两个字段——word和definition。\r\n这里封装了一个工具类：\r\n```\r\n/**\r\n * Created by chenchao on 16/8/18.\r\n * 该工具类通过解析res/raw下的txt文件，创建一个虚拟表，并提供查询方法\r\n * 虚拟表与SQLite表的运行方式类似，但虚拟表是通过回调来向内存中的对象进行读取和写入\r\n * 提供两个查询方法，分别返回一个Vocabulary对象列表和一个Vocabulary对象\r\n */\r\npublic class DatabaseTable {\r\n    private static final String TAG = \"DictionaryDatabase\";\r\n\r\n    //字典的表中将要包含的列名\r\n    public static final String COL_WORD = \"WORD\";\r\n    public static final String COL_DEFINITION = \"DEFINITION\";\r\n\r\n    private static final String DATABASE_NAME = \"DICTIONARY\";   //数据库名\r\n    private static final String FTS_VIRTUAL_TABLE = \"FTS\";  //表名\r\n    private static final int DATABASE_VERSION = 1;\r\n\r\n    private final DatabaseOpenHelper mDatabaseOpenHelper;\r\n\r\n    public DatabaseTable(Context context) {\r\n        mDatabaseOpenHelper = new DatabaseOpenHelper(context);\r\n    }\r\n\r\n    private static class DatabaseOpenHelper extends SQLiteOpenHelper {\r\n\r\n        private final Context mHelperContext;\r\n        private SQLiteDatabase mDatabase;\r\n\r\n        //创建虚拟表的SQL语句\r\n        private static final String FTS_TABLE_CREATE =\r\n                \"CREATE VIRTUAL TABLE \" + FTS_VIRTUAL_TABLE +\r\n                        \" USING fts3 (\" +\r\n                        COL_WORD + \", \" +\r\n                        COL_DEFINITION + \")\";\r\n\r\n        DatabaseOpenHelper(Context context) {\r\n            super(context, DATABASE_NAME, null, DATABASE_VERSION);\r\n            mHelperContext = context;\r\n        }\r\n\r\n        @Override\r\n        public void onCreate(SQLiteDatabase db) {\r\n            mDatabase = db;\r\n            mDatabase.execSQL(FTS_TABLE_CREATE);\r\n            loadDictionary();\r\n        }\r\n\r\n        @Override\r\n        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\r\n            Log.w(TAG, \"Upgrading database from version \" + oldVersion + \" to \"\r\n                    + newVersion + \", which will destroy all old data\");\r\n            db.execSQL(\"DROP TABLE IF EXISTS \" + FTS_VIRTUAL_TABLE);\r\n            onCreate(db);\r\n        }\r\n\r\n\r\n        //下面的代码会向你展示如何读取一个内容为单词和解释的文本文件(位于res/raw/definitions.txt)，如何解析文件与如何将文件中的数据按行插入虚拟表中。\r\n        //为防止UI锁死这些操作会在另一条线程中执行。\r\n        private void loadDictionary() {\r\n            new Thread(new Runnable() {\r\n                public void run() {\r\n                    try {\r\n                        loadWords();\r\n                    } catch (IOException e) {\r\n                        throw new RuntimeException(e);\r\n                    }\r\n                }\r\n            }).start();\r\n        }\r\n\r\n        /**\r\n         * 解析txt文件中的内容，并将解析后的单词记录添加到虚拟表中\r\n         * @throws IOException\r\n         */\r\n        private void loadWords() throws IOException {\r\n            final Resources resources = mHelperContext.getResources();\r\n            InputStream inputStream = resources.openRawResource(R.raw.definitions);\r\n            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\r\n\r\n            try {\r\n                String line;\r\n                while ((line = reader.readLine()) != null) {\r\n                    String[] strings = TextUtils.split(line, \"-\");\r\n                    long id = addWord(strings[0].trim(), strings[1].trim());\r\n                    if (id < 0) {\r\n                        Log.e(TAG, \"unable to add word: \" + strings[0].trim());\r\n                    }\r\n                }\r\n            } finally {\r\n                reader.close();\r\n            }\r\n        }\r\n\r\n        /**\r\n         * 添加单词到虚拟表中\r\n         * @param word\r\n         * @param definition\r\n         * @return\r\n         */\r\n        private long addWord(String word, String definition) {\r\n            ContentValues initialValues = new ContentValues();\r\n            initialValues.put(COL_WORD, word);\r\n            initialValues.put(COL_DEFINITION, definition);\r\n\r\n            return mDatabase.insert(FTS_VIRTUAL_TABLE, null, initialValues);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 模糊查询，使用头匹配，用来提供一个list,最多只取10条数据\r\n     * @param query 查询关键字\r\n     * @return List<Vocabulary>\r\n     */\r\n    public List<Vocabulary> getWordsMatches(String query) {\r\n        List<Vocabulary> list=new ArrayList<Vocabulary>();\r\n\r\n        SQLiteQueryBuilder builder = new SQLiteQueryBuilder();\r\n        builder.setTables(FTS_VIRTUAL_TABLE);\r\n\r\n        SQLiteDatabase db = mDatabaseOpenHelper.getReadableDatabase();\r\n        String selection = COL_WORD + \" MATCH ?\";\r\n        String[] selectionArgs = new String[] {query+\"*\"};\r\n        String[] columns=new String[]{COL_WORD,COL_DEFINITION};\r\n\r\n        Cursor cursor = builder.query(db, columns, selection, selectionArgs, null, null, null);\r\n        Vocabulary vocabulary;\r\n        int count=0;\r\n        //最多只取10条数据\r\n        while(cursor.moveToNext() && count < 10){\r\n            String word = cursor.getString(cursor.getColumnIndex(\"WORD\"));\r\n            String definition = cursor.getString(cursor.getColumnIndex(\"DEFINITION\"));\r\n            vocabulary=new Vocabulary(word,definition);\r\n            list.add(vocabulary);\r\n            count++;\r\n        }\r\n        return list;\r\n    }\r\n\r\n    /**\r\n     * 精确查询，根据查询条件返回一个Vocabulary对象\r\n     * @param query 查询关键字\r\n     * @return Vocabulary\r\n     */\r\n    public Vocabulary getWord(String query) {\r\n        Vocabulary vocabulary = new Vocabulary();\r\n        SQLiteQueryBuilder builder = new SQLiteQueryBuilder();\r\n        builder.setTables(FTS_VIRTUAL_TABLE);\r\n\r\n        SQLiteDatabase db = mDatabaseOpenHelper.getReadableDatabase();\r\n        String selection = COL_WORD + \" = ?\";\r\n        String[] selectionArgs = new String[] {query};\r\n        String[] columns=new String[]{COL_WORD,COL_DEFINITION};\r\n\r\n        Cursor cursor = builder.query(db, columns, selection, selectionArgs, null, null, null);\r\n        while(cursor.moveToNext()){\r\n            String word = cursor.getString(cursor.getColumnIndex(\"WORD\"));\r\n            String definition = cursor.getString(cursor.getColumnIndex(\"DEFINITION\"));\r\n            vocabulary=new Vocabulary(word,definition);\r\n        }\r\n        return vocabulary;\r\n    }\r\n}\r\n```\r\n然后就可以在SearchResultsActivity中使用该类，并把结果展示到界面中。\r\n先给SearchResultsActivity创建一个布局文件，这里只是一个简单的TextView，就不展示代码了。然后在handleIntent方法中加入以下代码：\r\n```\r\nVocabulary vocabulary=db.getWord(query);\r\nif (vocabulary.getWord()==null){\r\n    textView.setText(\"没有匹配的数据...\");\r\n}else {\r\n    textView.setText(vocabulary.getWord()+\":\"+vocabulary.getDefinition());\r\n}\r\n```\r\n这样就把搜索结果展示在界面中了。\r\n### 下面说明SearchView和ListView结合的使用，实现有道词典查询单词的效果\r\n现在MainActivity的布局文件中加入一个ListView：\r\n```\r\n<ListView android:id=\"@+id/list\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"wrap_content\"\r\n    android:drawSelectorOnTop=\"true\"\r\n    android:scrollbars=\"vertical\" />\r\n```\r\n先给SearchView设置一个监听器，在搜索框的值改变时更新ListView的内容，在onCreateOptionsMenu中加入如下代码\r\n```\r\n//给SearchView设置监听器，以便更新ListView的内容\r\nMenuItem searchItem = menu.findItem(R.id.search);\r\nsearchView = (SearchView) searchItem.getActionView();\r\nsearchView.setOnQueryTextListener(new SearchView.OnQueryTextListener() { //搜索时会触发这个事件搜索即可\r\n    @Override\r\n    public boolean onQueryTextSubmit(String query) {\r\n        return false;\r\n    }\r\n    @Override\r\n    public boolean onQueryTextChange(String newText) {\r\n        if(newText.length()!=0){\r\n            //当searchView的内容改变时，更新ListView\r\n            updateListView(newText);\r\n        }\r\n        return false;\r\n    }\r\n});\r\n```\r\nupdateListView()中实现更新ListView\r\n```\r\npublic void updateListView(String newText){\r\n    List<Vocabulary> vocabularies=db.getWordsMatches(newText);\r\n    words=new String[vocabularies.size()];\r\n    for (int i=0;i<vocabularies.size();i++){\r\n        words[i]=vocabularies.get(i).getWord();\r\n    }\r\n    ArrayAdapter<String> aadapter=new ArrayAdapter<String>(getApplicationContext(), android.R.layout.simple_expandable_list_item_1, words);\r\n    listView.setAdapter(aadapter);\r\n}\r\n```\r\n最后给这个ListView添加一个监听器,点击每个item时把item的值作为搜索关键字\r\n```\r\nlistView=(ListView)findViewById(R.id.list);\r\n//给ListView设置监听器，点击每个item时把item的值作为搜索关键字\r\nlistView.setOnItemClickListener(new AdapterView.OnItemClickListener() {\r\n    @Override\r\n    public void onItemClick(AdapterView<?> parent, View view, int position, long id) {\r\n        String word=words[position];\r\n        searchView.setQuery(word,true);\r\n    }\r\n});\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}